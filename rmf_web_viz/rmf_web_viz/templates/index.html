<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Open-RMF Web Visualizer</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/4.0.1/socket.io.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.0/p5.js"></script>
    <style>
        body { font-family: Arial, sans-serif; margin: 0; padding: 20px; background-color: #f0f0f0; }
        #canvas-container { border: 1px solid #ccc; background-color: white; margin-top: 10px; width: 800px; height: 600px; overflow: hidden; position: relative; }
        .controls { margin-bottom: 10px; }
        .sidebar { float: right; width: 300px; background: white; padding: 10px; border-left: 1px solid #ccc; height: 600px; overflow-y: auto; }
        .robot-card { border: 1px solid #ddd; padding: 5px; margin-bottom: 5px; border-radius: 4px; }
        .status-ok { color: green; }
        .status-warn { color: orange; }
    </style>
</head>
<body>
    <h1>Open-RMF Web Visualizer</h1>
    
    <div class="controls">
        <label for="level-select">Level:</label>
        <select id="level-select">
            <option value="">Waiting for map...</option>
        </select>
        <span id="connection-status">Connecting...</span>
    </div>

    <div style="display: flex;">
        <div id="canvas-container">
            <!-- P5.js canvas will be here -->
        </div>
        <div class="sidebar" id="fleet-sidebar">
            <h3>Fleets</h3>
            <div id="fleets-list"></div>
        </div>
    </div>

    <script>
        const socket = io();
        let currentMap = null;
        let fleetStates = {};
        let currentLevel = null;
        let mapScale = 20.0; // Pixels per meter
        let offsetX = 400;
        let offsetY = 300;
        let levelImages = {}; // Cache for loaded P5 images: { levelName: [p5Image, ...] }
        let scheduleMarkers = {}; // Cache for markers { ns: { id: markerData } }

        // SocketIO Events
        socket.on('connect', () => {
            document.getElementById('connection-status').innerText = 'Connected';
            document.getElementById('connection-status').style.color = 'green';
            // Fetch map immediately in case we missed the socket event
            fetchMap();
        });

        function fetchMap() {
            fetch('/api/map')
                .then(response => response.json())
                .then(data => {
                    // Check if data is valid map object
                    if (data && data.name) {
                        console.log('Map fetched via API', data);
                        currentMap = data;
                        loadMapImages();
                        updateLevelSelect();
                    } else {
                        console.log('API returned empty map or invalid data');
                    }
                })
                .catch(err => console.error('Failed to fetch map:', err));
        }

        socket.on('disconnect', () => {
            document.getElementById('connection-status').innerText = 'Disconnected';
            document.getElementById('connection-status').style.color = 'red';
        });

        socket.on('map_update', (data) => {
            console.log('Map received', data);
            currentMap = data;
            loadMapImages();
            updateLevelSelect();
        });

        function loadMapImages() {
            if (!currentMap || !currentMap.levels) return;
            
            levelImages = {}; // Reset cache
            
            currentMap.levels.forEach(level => {
                if (level.images) {
                    level.images.forEach(imgData => {
                        if (imgData.data_base64) {
                            // Assume png if not specified, though RMF usually provides encoding
                            const encoding = imgData.encoding || 'png';
                            const imgUrl = 'data:image/' + encoding + ';base64,' + imgData.data_base64;
                            
                            loadImage(imgUrl, (p5Img) => {
                                if (!levelImages[level.name]) {
                                    levelImages[level.name] = [];
                                }
                                // Store image with its metadata
                                levelImages[level.name].push({
                                    img: p5Img,
                                    meta: imgData
                                });
                                console.log('Loaded image for level:', level.name, imgData.name);
                            }, (err) => {
                                console.error('Failed to load image:', err);
                            });
                        }
                    });
                }
            });
        }

        socket.on('fleet_update', (data) => {
            fleetStates[data.name] = data;
            updateFleetSidebar();
        });

        socket.on('schedule_markers_update', (data) => {
            scheduleMarkers = data;
        });

        function updateLevelSelect() {
            const select = document.getElementById('level-select');
            select.innerHTML = '';
            if (currentMap && currentMap.levels) {
                console.log('Updating levels:', currentMap.levels.length);
                currentMap.levels.forEach(level => {
                    const option = document.createElement('option');
                    option.value = level.name;
                    option.innerText = level.name;
                    select.appendChild(option);
                });
                
                if (currentMap.levels.length > 0) {
                    // Auto-select first level if needed
                    if (!currentLevel || !currentMap.levels.find(l => l.name === currentLevel)) {
                        currentLevel = currentMap.levels[0].name;
                        select.value = currentLevel;
                        console.log('Auto-selected level:', currentLevel);
                    } else {
                        select.value = currentLevel;
                    }
                }
            } else {
                console.warn('No levels found in map data');
            }
        }

        document.getElementById('level-select').addEventListener('change', (e) => {
            currentLevel = e.target.value;
        });

        function updateFleetSidebar() {
            const list = document.getElementById('fleets-list');
            list.innerHTML = '';
            
            for (const [fleetName, fleetData] of Object.entries(fleetStates)) {
                const fleetHeader = document.createElement('h4');
                fleetHeader.innerText = fleetName;
                list.appendChild(fleetHeader);

                fleetData.robots.forEach(robot => {
                    const div = document.createElement('div');
                    div.className = 'robot-card';
                    div.innerHTML = `
                        <strong>${robot.name}</strong><br>
                        Batt: ${robot.battery_percent.toFixed(1)}%<br>
                        Loc: ${robot.location.level_name} (${robot.location.x.toFixed(2)}, ${robot.location.y.toFixed(2)})<br>
                        Status: ${robot.status}
                    `;
                    list.appendChild(div);
                });
            }
        }

        // P5.js Visualization
        function setup() {
            const canvas = createCanvas(800, 600);
            canvas.parent('canvas-container');
        }

        function draw() {
            background(255);
            
            // Apply transformations
            translate(offsetX, offsetY);
            scale(mapScale); // Zoom
            
            // Draw Coordinate Grid (Origin)
            stroke(200);
            strokeWeight(1/mapScale);
            line(-100, 0, 100, 0);
            line(0, -100, 0, 100);

            if (currentMap && currentLevel) {
                const level = currentMap.levels.find(l => l.name === currentLevel);
                if (level) {
                    drawLevel(level);
                }
            }

            drawSchedule();
            drawRobots();
        }

        function drawSchedule() {
            // Draw markers
            // We assume schedule markers are relevant for current level or global.
            // RMF schedule markers usually are z=0 but might not have level info directly in marker msg
            // unless we map z-height to levels. 
            // For simplicity, we draw them all or check if they are within bounding box of level?
            // Usually schedule markers are 2D on map frame.
            
            for (const ns in scheduleMarkers) {
                for (const mid in scheduleMarkers[ns]) {
                    const m = scheduleMarkers[ns][mid];
                    
                    // Check lifetime (optional, simple check)
                    // if (m.lifetime > 0 && (Date.now()/1000 - m.timestamp) > m.lifetime) continue;

                    push();
                    
                    if (m.type === 4) { // LINE_STRIP
                        noFill();
                        stroke(m.color.r * 255, m.color.g * 255, m.color.b * 255, m.color.a * 255);
                        strokeWeight(Math.max(m.scale.x * 20, 2) / mapScale); // scale.x is line width in meters usually
                        
                        beginShape();
                        for (const p of m.points) {
                            // Coordinate transform: x, -y
                            vertex(p.x, -p.y);
                        }
                        endShape();
                    } else if (m.type === 3) { // CYLINDER
                        // Draw at pose
                        translate(m.pose.x, -m.pose.y);
                        
                        fill(m.color.r * 255, m.color.g * 255, m.color.b * 255, m.color.a * 255);
                        noStroke();
                        // Cylinder in 2D is a circle
                        // scale.x and scale.y are diameter
                        ellipse(0, 0, m.scale.x, m.scale.y);
                    }
                    
                    pop();
                }
            }
        }

        function drawLevel(level) {
            // Draw images first (background)
            if (levelImages[level.name]) {
                levelImages[level.name].forEach(item => {
                    const img = item.img;
                    const meta = item.meta;
                    
                    // meta.scale is meters per pixel
                    // We want to draw it in world coordinates (meters)
                    // The drawing context is already scaled by mapScale (pixels/meter)
                    // So if we draw with width/height in meters, it will be correct.
                    
                    const imgWidthMeters = img.width * meta.scale;
                    const imgHeightMeters = img.height * meta.scale;
                    
                    push();
                    translate(meta.x, -meta.y); // Position in meters (flip Y)
                    
                    // Note: RMF coordinate system Y is up, Image Y is down (pixel coordinates).
                    // Since we map RMF +Y to Screen -Y (up), and Image +Y (down) to Screen +Y (down),
                    // the Image Y axis is actually inverted relative to RMF Y axis.
                    // But visually on screen, we want "Image Up" to be "Screen Up".
                    // image() draws "Image Up" at y=0, and "Image Down" at y=h.
                    // So we just draw it normally.
                    
                    // However, we need to check if the image origin needs adjustment.
                    // Usually AffineImage origin is top-left.
                    
                    // Draw image
                    image(img, 0, 0, imgWidthMeters, imgHeightMeters);
                    
                    pop();
                });
            }

            if (!level.graphs) return;

            level.graphs.forEach(graph => {
                if (graph.type === 'wall') {
                    stroke(0); // Black for walls
                    strokeWeight(3/mapScale);
                } else {
                    stroke(200); // Light gray for nav paths
                    strokeWeight(1/mapScale);
                }

                if (graph.edges && graph.vertices) {
                    graph.edges.forEach(edge => {
                        const v1 = graph.vertices[edge.v1];
                        const v2 = graph.vertices[edge.v2];
                        if (v1 && v2) {
                            line(v1.x, -v1.y, v2.x, -v2.y);
                        }
                    });
                }
                
                // Optional: Draw vertices for nav graphs to see waypoints
                if (graph.type === 'nav') {
                    fill(150);
                    noStroke();
                    graph.vertices.forEach(v => {
                        ellipse(v.x, -v.y, 0.2, 0.2);
                    });
                }
            });
        }

        function drawRobots() {
            for (const fleet of Object.values(fleetStates)) {
                for (const robot of fleet.robots) {
                    // Only draw robots on current level
                    if (robot.location.level_name === currentLevel) {
                        push();
                        translate(robot.location.x, -robot.location.y); // Flip Y
                        rotate(-robot.location.yaw); // Rotate robot
                        
                        // Draw robot body
                        fill(0, 100, 255);
                        stroke(0);
                        strokeWeight(1/mapScale);
                        ellipse(0, 0, 0.5, 0.5); // 0.5m diameter robot
                        
                        // Draw heading
                        line(0, 0, 0.3, 0);
                        
                        // Label
                        scale(1, -1); // Unflip text
                        rotate(robot.location.yaw);
                        fill(0);
                        noStroke();
                        textSize(0.3);
                        textAlign(CENTER);
                        text(robot.name, 0, -0.4);
                        
                        pop();
                    }
                }
            }
        }

        // Simple Pan/Zoom interaction
        function mouseDragged() {
            offsetX += movedX;
            offsetY += movedY;
        }

        function mouseWheel(event) {
            let zoomSensitivity = 0.05;
            let zoom = 1.0;
            if (event.delta > 0) {
                zoom = 1.0 - zoomSensitivity;
            } else {
                zoom = 1.0 + zoomSensitivity;
            }
            mapScale *= zoom;
            return false;
        }
    </script>
</body>
</html>

